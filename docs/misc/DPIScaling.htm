<!DOCTYPE HTML>
<html lang="en">
<head>
<title>DPI Scaling | AutoHotkey v2</title>
<meta name="description" content="Describes issues relating to DPI scaling." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>DPI Scaling</h1>

<p>DPI scaling is a function performed either by the operating system or by the application, to increase the visual size of content proportionate to the "dots per inch" setting of the display. Generally it allows content to appear at the same physical size on systems with different display resolutions, or to at least be usable on very high-resolution displays. Sometimes a user may increase the DPI setting just to make content larger and more comfortable to read.</p>
<p><a href="../Variables.htm#ScreenDPI">A_ScreenDPI</a> typically returns the DPI setting which the primary display had at the time the script started. This is known as the "system DPI", although processes started at different times can have different values.</p>
<p>There are two types of DPI scaling that relate to AutoHotkey: Gui DPI Scaling and OS DPI Scaling.</p>

<h2 id="Gui_DPI_Scaling">Gui DPI Scaling</h2>
<p>Automatic scaling is performed by the Gui and GuiControl methods/properties by default, so that GUI scripts with hard-coded positions, sizes and margins will tend to scale as appropriate on high DPI screens. If this interferes with the script, or if the script will do its own scaling, the automatic scaling can be disabled. For more details, see the <a href="../lib/Gui.htm#DPIScale">-DPIScale</a> option.</p>

<h2 id="OS_DPI_Scaling">OS DPI Scaling</h2>
<p>For applications which are not DPI-aware, the operating system automatically scales coordinates passed to and returned from certain system functions. This type of scaling typically affects AutoHotkey in two scenarios:</p>
<ul>
  <li>Systems with multiple monitors where not all monitors are set to the same scale.</li>
  <li>Whenever the display scale setting differs from what it was when the program started.</li>
</ul>
<p>The exact scaling done depends on which system function is being called, the DPI awareness of the script and potentially the DPI awareness of the target window.</p>

<h3 id="Per-Monitor_DPI_Awareness">Per-Monitor DPI Awareness</h3>
<p>On Windows 8.1 and later, secondary screens can have different DPI settings, and "per-monitor DPI-aware" applications are expected to scale their windows according to the DPI of whichever screen they are currently on, adapting dynamically when the window moves between screens.</p>
<p>For applications which are not per-monitor DPI-aware, the system performs bitmap scaling to allow windows to change sizes when they move between screens, and hides this from the application by reporting coordinates and sizes scaled to the global DPI setting that the application expects to have. For instance, on an 11 inch 4K screen, a GUI designed to display at 96 dpi (100&nbsp;%) would be almost impossible to use, whereas upscaling it by 200&nbsp;% would make it usable.</p>
<p>AutoHotkey v2.0 is not designed to perform per-monitor scaling, and therefore has not been marked as per-monitor DPI-aware. This is a boon, for instance, when moving a GUI window between a large external screen with 100&nbsp;% DPI and a smaller screen with 200&nbsp;% DPI. However, automatic scaling does have negative implications.</p>
<p>In order of the system's automatic scaling to work, system functions such as <a href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow">MoveWindow</a> and <a href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowrect">GetWindowRect</a> automatically scale the coordinates that they accept or return. When AutoHotkey uses these functions to work with external windows, this often produces unexpected results if the coordinates are not on the primary screen. To add further confusion, some functions scale coordinates based on which screen the script's last active window was displayed on.</p>

<h2 id="Workarounds">Workarounds</h2>
<p>On Windows 10 version 1607 and later, the <a href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setthreaddpiawarenesscontext">SetThreadDpiAwarenessContext</a> system function can be used to change the program's DPI awareness setting at runtime. For instance, enabling per-monitor DPI awareness disables the scaling performed by the system, so built-in functions such as <a href="../lib/WinMove.htm">WinMove</a> and <a href="../lib/WinGetPos.htm">WinGetPos</a> will accept or return coordinates in pixels, untouched by DPI scaling. However, if a GUI is sized for a screen with 100&nbsp;% DPI and then moved to a screen with 200&nbsp;% DPI, it will not adjust automatically, and may be very hard to use.</p>
<p>To enable per-monitor DPI awareness, call the following function prior to using functions that are normally affected by DPI scaling:</p>
<pre>DllCall("SetThreadDpiAwarenessContext", "ptr", -3, "ptr")</pre>
<p>On Windows 10 version 1703 and later, -3 can be replaced with -4 to enable the "Per Monitor v2" mode. This enables scaling of dialogs, menus, tooltips and some other things. However, it also causes the non-client area (title bar) to scale, which may cause the window's client area to be too small unless the script is designed to adjust for it (such as by responding to the <a href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged">WM_DPICHANGED message</a>). This can be avoided by setting the context to -3 before creating the GUI, but -4 before creating any tooltips, menus or dialogs.</p>

<h3 id="New_Threads">New Threads</h3>
<p>When the <a href="https://learn.microsoft.com/windows/win32/winmsg/window-procedures">window procedure</a> for a window is called by the system, it automatically sets the current DPI awareness context to whichever context was in use when the window was created. The context for a new <a href="Threads.htm">script thread</a> therefore depends on whether it was launched directly from AutoHotkey's message loop or via a window procedure.</p>
<ul>
  <li>Under typical conditions, posted messages are handled directly from AutoHotkey's message loop, which means that whatever context was already in effect remains in effect. This includes most events which start new script threads, such as hotkeys, hotstrings and timers.</li>
  <li>Script threads corresponding to sent (not posted) messages are started from within the window procedure, which means that the context is always set based on the target window.</li>
  <li>Posted messages are typically dispatched to a window procedure if they are received during a modal message loop. Modal message loops are (for example) used by modal dialog boxes and menus, or while the user is moving a window or performing drag-drop.</li>
  <li>Non-GUI events are associated with the script's <a href="../Program.htm#main-window">main window</a>, and therefore receive the program-default DPI awareness context. This is usually as set in the program's manifest, but could be overridden by application compatibility settings.</li>
</ul>

<h3 id="Mixed_Settings">Mixed Settings</h3>
<p>A per-monitor DPI aware GUI window is expected to adjust automatically when it receives a <a href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged">WM_DPICHANGED message</a>. AutoHotkey v2.0 GUI windows do not respond to this message by default. If correctly implementing this type of dynamic scaling is too difficult, a simpler alternative is to temporarily disable per-monitor DPI awareness immediately prior to creating the GUI. For example:</p>
<pre><em>; Set the "system DPI aware" mode which is the default in AutoHotkey v2.0:</em>
try dac := DllCall("SetThreadDpiAwarenessContext", 'ptr', -2, 'ptr')
<em>; Create the GUI, which will permanently be "system DPI aware":</em>
MyGui := Gui()
<em>; Restore the previous mode for any subsequent function calls:</em>
IsSet(dac) &amp;&amp; DllCall("SetThreadDpiAwarenessContext", 'ptr', dac, 'ptr')
</pre>
<p>The additional lines have no effect if the OS does not support SetThreadDpiAwarenessContext or the program was already in system DPI aware mode.</p>
<p>If only some of the GUI's controls do not scale well, system DPI aware (or DPI unaware) controls can be hosted on a per-monitor DPI aware window. Mixed hosting must be enabled prior to creating the window (requires Windows 10 version 1803 or later):</p>
<pre><em>; Create a GUI window which can host less-aware child windows:</em>
try dhb := DllCall("SetThreadDpiHostingBehavior", 'int', 1)
MyGui := Gui()
IsSet(dhb) &amp;&amp; DllCall("SetThreadDpiHostingBehavior", 'int', dhb)

<em>; Add a "system DPI aware" control:</em>
try dac := DllCall("SetThreadDpiAwarenessContext", 'ptr', -2, 'ptr')
MyListView := MyGui.AddListView()
IsSet(dac) &amp;&amp; DllCall("SetThreadDpiAwarenessContext", 'ptr', dac, 'ptr')
</pre>

<h3 id="Compiled_Scripts">Compiled Scripts</h3>
<p>Per-monitor DPI awareness can be enabled process-wide by setting the "dpiAware" and "dpiAwareness" elements in the compiled script's manifest (an embedded XML resource). For details of the proper use and effect of these settings, see <a href="https://learn.microsoft.com/windows/win32/hidpi/setting-the-default-dpi-awareness-for-a-process#setting-default-awareness-with-the-application-manifest">Setting default awareness with the application manifest</a>. For example, the manifest in AutoHotkey v2.0.19 includes the following:</p>
<pre>&lt;v3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings"
                 xmlns:ws2="http://schemas.microsoft.com/SMI/2016/WindowsSettings"&gt;
  &lt;dpiAware&gt;true&lt;/dpiAware&gt;
  &lt;ws2:longPathAware&gt;true&lt;/ws2:longPathAware&gt;
&lt;/v3:windowsSettings&gt;</pre>
<p>As explained in the Microsoft documentation, it may be desirable to include both "dpiAware" and "dpiAwareness", which belong to different XML namespaces. As "longPathAware" and "dpiAwareness" belong to the same namespace, the XML can be optimized by moving some things around. The following enables per-monitor DPI awareness (v2 if available, otherwise v1):</p>
<pre>&lt;v3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings"&gt;
  &lt;dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings"&gt;true/pm&lt;/dpiAware&gt;
  &lt;dpiAwareness&gt;PerMonitorV2&lt;/dpiAwareness&gt;
  &lt;longPathAware&gt;true&lt;/longPathAware&gt;
&lt;/v3:windowsSettings&gt;</pre>

<h3 id="Compatibility_Settings">Compatibility Settings</h3>
<p>The program's default DPI awareness can be overridden by compatibility settings, which can be set in the properties of an AutoHotkey executable file, in the properties of a shortcut file, or by setting the <code>__COMPAT_LAYER</code> environment variable to include the keyword <code>DpiUnaware</code> or the keyword <code>HighDpiAware</code>. Enabling DPI awareness using this method may have unwanted effects; in particular, MsgBox windows may not adjust automatically when moved between screens.</p>

</body>
</html>
